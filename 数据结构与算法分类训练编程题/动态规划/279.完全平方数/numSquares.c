/*
给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.

示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.

*/

//这道题和322零钱兑换类似

//动态规划
int numSquares(int n){
    if(n < 1)   return 0;
    int dp[n+1];

    for(int i=0;i<n+1;i++)
        dp[i] = i; //dp[i]表示数字为i时的最小完全平方数个数,最多全部选择1

    //n=1只有1，所以直接从2开始
    for(int i=2;i<n+1;i++)
    {
        for(int j=1;j*j<=i;j++) //对于n来说，它的选择或者树杈只有<=它的平方数->j*j<=i
        {
            dp[i] = fmin(dp[i],dp[i-j*j]+1);//不选，还是dp[i]; 选择当前这个数dp[i-j*j]+1，然后在去掉该值的数中继续找
        }
    }
    return dp[n];
}

//数学定理
/*
这道题如果知道数学定理之后，相当于告诉你：

    1.任何正整数都可以拆分成不超过4个数的平方和 ---> 答案只可能是1,2,3,4
    2.如果一个数最少可以拆成4个数的平方和，则这个数还满足 n = (4^a)*(8b+7) ---> 因此可以先看这个数是否满足上述公式，如果不满足，答案就是1,2,3了
    3.如果这个数本来就是某个数的平方，那么答案就是1，否则答案就只剩2,3了
    4.如果答案是2，即n=a^2+b^2，那么我们可以枚举a，来验证，如果验证通过则答案是2
    5.只能是3
*/

int numSquares(int n) 
{
    //先根据上面提到的公式来缩小n
    while(n % 4 == 0) 
    {
        n /= 4;
    }
    //如果满足公式 则返回4
    if(n % 8 == 7) 
        return 4;
    
    //再判断缩小后的数是否可以由一个数的平方或者两个数平方的和组成
    int a = 0;
    while ((a*a) <= n)
    {
        int b = sqrt((n - a * a));
        if(a*a + b*b == n) 
        {
            //如果可以 在这里返回
            if(a != 0 && b != 0)
                return 2;
            else
                return 1;       
        }
        a++;
    }
    //如果不行 返回3
    return 3;
}
