### 方法一：深度优先遍历 DFS

* __深度优先搜索__： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底， 再回溯至上个节点，沿另一个方向搜索，以此类推。
* __剪枝__： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。

#### 算法解析：

* __递归参数__： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。
* __终止条件__： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 0 ，代表不计入可达解。
* __递推工作__：
    1. 标记当前单元格 ：将索引 (i, j) 存入 visited 中，代表此单元格已被访问过。
    2. 搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。  

* __回溯返回值__： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。

#### 复杂度分析：

    M,NM, NM,N 分别为矩阵行列大小。

* __时间复杂度 O(MN)__ ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) 。
* __空间复杂度 O(MN)__ ： 最差情况下，Set visited 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。


### 方法二：广度优先遍历 BFS

* __BFS/DFS__ ： 两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。
* __BFS 实现__： 通常利用队列实现广度优先遍历。

#### 算法解析：

* __初始化__： 将机器人初始点 (0,0) 加入队列 queue ；
* __迭代终止条件__： queue 为空。代表已遍历完所有可达解。
* __迭代工作__：
    1. 单元格出队： 将队首单元格的 索引、数位和 弹出，作为当前搜索单元格。
    2. 判断是否跳过： 若 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。
    3. 标记当前单元格 ：将单元格索引 (i, j) 存入 visited 中，代表此单元格 已被访问过 。
    4. 单元格入队： 将当前元素的 下方、右方 单元格的 索引、数位和 加入 queue 。
* __返回值__： visited 的长度 len(visited) ，即可达解的数量。
