## 回溯

回溯算法事实上就是在一个树形问题上做深度优先遍历，因此 **首先需要把问题转换为树形问题**。

最好动手画出树，然后思考**剪枝**，把不可行的分支**判断条件**找出来然后剪掉。



解决一个回溯问题，实际上就是一个决策树的遍历过程。一般来说，我们需要解决三个问题：

1. 路径：也就是已经做出的选择。

2. 选择列表：也就是你当前可以做的选择。

3. 结束条件：也就是到达决策树底层，无法再做选择的条件。



基本框架：其实都是N叉树的选择问题，dp也是，单链表就是一叉树，然后二叉树。

**人生就是一颗N叉树，处处充满了选择，我们无法站在上帝视角俯瞰人生的N叉树进行剪枝，我们只能像DFS一样摸索着前进与回溯，直到找到人生的答案。**

```c++
vector<vector<int>>res;
vector<int>path;

public void backtrack(路径，选择列表){
    if(满足结束条件){
        res.push_back(结果);
    }
    for(选择：选择列表){
        做出选择;
        backtrack(路径，选择列表);
        撤销选择;
    }
}

```

其中最关键的点就是：**在递归之前做选择，在递归之后撤销选择**。

