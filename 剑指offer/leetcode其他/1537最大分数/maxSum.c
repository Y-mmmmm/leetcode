#include <stdio.h>
#include <stdlib.h>

/*
你有两个 有序 且数组内元素互不相同的数组 nums1 和 nums2 。

一条 合法路径 定义如下：

    选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。
    从左到右遍历当前数组。
    如果你遇到了 nums1 和 nums2 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。

得分定义为合法路径中不同数字的和。

请你返回所有可能合法路径中的最大得分。

由于答案可能很大，请你将它对 10^9 + 7 取余后返回。

输入：nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]
输出：30
解释：合法路径包括：
[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历）
[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]  （从 nums2 开始遍历）
最大得分为上图中的绿色路径 [2,4,6,8,10] 。

示例 2：
输入：nums1 = [1,3,5,7,9], nums2 = [3,5,100]
输出：109
解释：最大得分由路径 [1,3,5,100] 得到。

示例 3：
输入：nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]
输出：40
解释：nums1 和 nums2 之间无相同数字。
最大得分由路径 [6,7,8,9,10] 得到。

示例 4：
输入：nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]
输出：61

*/


/*
分析：题目的意思是，两个有序数组存在多个公共节点，在遇到公共节点时可以选择切换路径，最后遍历到末尾时这条路径的最大值
思路：遇到公共节点问题，考虑双指针法
     1.定义两个指针指向数组开头
     2.比较当前两个指针指向的元素大小，让元素小的指针先走并累加和，遇到相等时，取当前最大的累加和加上这个相等的元素，
       然后清空之前的累加和，移动两个指针。
     3.重复第2步，直到加完最短的数组；然后继续叠加长的数组剩余部分；最后取各自累加和的最大值。
     4.对和求余
*/

int maxSum(int* nums1, int nums1Size, int* nums2, int nums2Size){
    int i = 0;
    int j = 0;
    long sum1 = 0;
    long sum2 = 0;
    long res = 0; //注意，为了防止溢出，选择long型

    while(i<nums1Size && j<nums2Size)
    {
        if(nums1[i] < nums2[j])
        {
            sum1 += nums1[i++]; //先累加小的元素
        }
        else if(nums1[i] > nums2[j])
        {
            sum2 += nums2[j++]; //同理
        }
        else //相等时
        {
            res += fmax(sum1,sum2) + nums1[i]; //取最大的累加和 + 当前相等的元素
            sum1 = 0;
            sum2 = 0; //清空，重新累加，减少溢出情况
            i++;
            j++;
        }
    }
    while(i<nums1Size)
    {
        sum1 += nums1[i++]; //加上剩下的
    }
    while(j<nums2Size)
    {
        sum2 += nums2[j++];//加上剩下的
    }

    res += fmax(sum1,sum2); //叠加剩余的最大值

    return res%((int)pow(10,9)+7);

}



