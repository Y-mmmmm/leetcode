#include <stdio.h>

/*
我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

说明:  

    注意：1 是丑数。
    n 不超过1690。

*/

/*
思路：丑数只能由 2，3，5 相乘组合而成

我们知道，丑数的排列肯定是1,2,3,4,5,6,8,10.... 然后有一个特点是，任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的，那么如何得到所有丑数呢？
现在[假设]有3个数组，分别是： 
A：{1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......} //三个数组只是抽象帮助理解，实际只有1个数组

B：{1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......}

C：{1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......}

那么所有丑数的排列，必定就是上面 ABC 3个数组的 合并 结果然后 去重 得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？
而这三个数组就刚好是{1,2,3,4,5,6,8,10....}乘以2,3,5得到的。

合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，然后比较这些指针所指的数中哪个最小，就将这个数放到结果数组中，然后该指针向后挪一位。

回到本题，要求丑数ugly数组中的第n项，而目前只知道ugly[0]=1，所以此时三个有序链表分别就只有一个元素：

A ：{1*2......}

B ：{1*3......}

C ：{1*5......}

假设三个数组的指针分别是i,j,k，此时均是指向第一个元素，然后比较 A[i]，B[j] 和 C[k]，得到的最小的数 A[i]，就是 ugly[1]，
此时ugly就变成{1,2}了，对应的ABC数组就分别变成了：

A ：{1*2，2*2......}

B ：{1*3, 2*3......}

C ：{1*5, 2*5......}

此时根据合并有序数组的原理，A数组指针i就指向了下一个元素，即'2*2'，而j和k依然分别指向 B[0] 和 C[0]，然后进行下一轮合并，
就是 A[1] 和 B[0] 和 C[0]比较，最小值作为 ugly[2].....如此循环n次，就可以得到 ugly[n] 了。

此外，注意到ABC三个数组实际上就是ugly[]*2，ugly[]*3和ugly[]*5的结果，
所以每次只需要比较 A[i]=ugly[i]*2，B[j]=ugly[j]*3和 C[k]=ugly[k]*5 的大小即可。然后谁最小，
就把对应的指针往后移动一个，为了去重，如果多个元素都是最小，那么这多个指针都要往后移动一个。

*/



#define min2(a,b)  (a)>(b)?(b):(a)

#define min3(a,b,c)   min2(min2(a,b),c) 

int nthUglyNumber(int n){
    if(n <= 0) return -1;

    int dp[n];

    dp[0] = 1;//最小丑数为1

    int p2=0,p3=0,p5=0;//指向2，3，5三个[数组]的指针

    for(int i=1;i<n;i++)
    {
        int tmp2 = dp[p2]*2;
        int tmp3 = dp[p3]*3;
        int tmp5 = dp[p5]*5;
        
        dp[i] = min3(tmp2,tmp3,tmp5);//去重，取最小丑数

        // 这里不用else if的原因是有可能dp(p3) * 2 == dp(p2) * 3
        // 这种情况两个指针都要后移
        if(tmp2 == dp[i])   p2++;
        if(tmp3 == dp[i])   p3++;
        if(tmp5 == dp[i])   p5++;
    }

    return dp[n-1];
}

